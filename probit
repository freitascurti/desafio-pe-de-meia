install.packages("plm")
install.packages("glmnet")
install.packages("fixest")
install.packages("plm")
install.packages("janitor")


# Carregando pacotes necessários
library(PNADcIBGE)
library(convey)
library(tidyverse)
library(gt)
library(scales)
library(dplyr)
library(haven)
library(fixest)
library(lme4)
library(plm)
library(janitor)

# Limpando o ambiente
rm(list=ls(all=TRUE))
gc()


####################################### Construindo a base de dados##############################################


# Filtrando as variáveis necessárias

variaveis_interesse <- c(
  "UPA", "V1008", "V1014", "V2003", "V2008", "V20081", "V20082", "V2009",
  "V3003A", "VD2004", "V3002A", "ID_DOMICILIO", "V2001", "VD4016",
  "VD4017", "VD2003", "VD4019", "V2007", "V3009A","VD2002", "V3006","VD3005", "V2010", "VD4020","V3002", "Ano", "Trimestre")


####################################### Criando base evasão ###################################################

# Carregar a base base_evasão
base_evasão <- readRDS("base_evasão")

# Filtrando a base para as variáveis de interesse
base_evasão<- base_evasão[, variaveis_interesse]



# Adicionar as novas colunas na base base_evasão
base_evasão <- base_evasão %>%
  # Criar a coluna id_individuo
  mutate(
    id_individuo = paste0(UPA, "_", V1008, "_", V1014, "_", V2003, "_", V2008, "_", V20081, "_", V20082)
  ) %>%
  # Organizar a base pelos identificadores e trimestres
  arrange(id_individuo, Ano, Trimestre) %>%
  # Adicionar as outras colunas e variáveis necessárias
  mutate(
    faixa_idade_14_24 = ifelse(V2009 >= 14 & V2009 <= 24, 1, 0),
    ensino_medio_dummie = ifelse(V3003A == "Regular do ensino médio", 1, 0),
    residencia_unipessoal = ifelse(VD2004 == "Unipessoal", 1, 0),
    rede_publica = ifelse(V3002A == "Rede pública", 1, 0),
    
    # Calcular RDPC (Renda Domiciliar Per Capita)
    RD = sum(VD4020, na.rm = TRUE),          # Rendimento domiciliar total
    V2001R = ifelse(!is.na(V2001), V2001[1], NA),  # Número de residentes no domicílio
    RDPC = RD / V2001R,                      # Renda domiciliar per capita
    
    # Criar a dummy para renda per capita menor que 706
    renda_per_capta_menor_706 = ifelse(RDPC < 706, 1, 0),
    
    # Adicionar a coluna de região
    região = case_when(
      substr(UPA, start = 1, stop = 1) == '1' ~ 'Norte',
      substr(UPA, start = 1, stop = 1) == '2' ~ 'Nordeste',
      substr(UPA, start = 1, stop = 1) == '3' ~ 'Sudeste',
      substr(UPA, start = 1, stop = 1) == '4' ~ 'Sul',
      substr(UPA, start = 1, stop = 1) == '5' ~ 'Centro-Oeste',
      TRUE ~ NA_character_
    ),
    
    # Identificar a educação da mãe e do pai
    is_mae = (as.numeric(V2007) == 2 & (as.numeric(VD2002) %in% c(1, 2, 6))),
    educacao_mae = ifelse(any(is_mae), VD3005[is_mae][1], NA),
    is_pai = (as.numeric(V2007) == 1 & (as.numeric(VD2002) %in% c(1, 2, 6))),
    educacao_pai = ifelse(any(is_pai), VD3005[is_pai][1], NA),
    
    # Criar a dummie de abandono: frequentando no trimestre anterior e não frequentando no trimestre atual
    evasão = ifelse(
      lag(V3002) == "Sim" & V3002 == "Não" & lag(Ano) == Ano,
      1,
      0
    )
  ) %>%
  # Remover as colunas auxiliares usadas para identificar pais e mães
  select(-is_mae, -is_pai)


# Filtrar os indivíduos que responderam tanto no T1 do ano T quanto no T1 do ano T+1
base_evasão_filtrada <- base_evasão %>%
  group_by(id_individuo) %>%
  filter(
    any(Ano == 2022 & Trimestre == 1) & any(Ano == 2023 & Trimestre == 1) |
      any(Ano == 2023 & Trimestre == 1) & any(Ano == 2024 & Trimestre == 1)
  ) %>%
  ungroup()

# Reorganizando as colunas para trazer as novas variáveis para o começo
base_evasão_filtrada <- base_evasão_filtrada %>%
  dplyr::select( 
    id_individuo,Ano, Trimestre, faixa_idade_14_24, ensino_medio_dummie, residencia_unipessoal,
    rede_publica, renda_per_capta_menor_706, RDPC, região, educacao_mae, educacao_pai, evasão,
    everything()
  )

## Removendo observações onde V20082 é igual a 9999
base_evasão_filtrada <- base_evasão_filtrada %>%
  filter(V20082 != 9999)

#######################################  Criando base abandono ###################################################

# Carregar a base base_abandono
base_abandono <- readRDS("base_abandono")

# Filtrando a base para as variáveis de interesse
base_abandono<- base_abandono[, variaveis_interesse]

# Adicionar as novas colunas na base base_evasão
base_abandono <- base_abandono %>%
  # Criar a coluna id_individuo
  mutate(
    id_individuo = paste0(UPA, "_", V1008, "_", V1014, "_", V2003, "_", V2008, "_", V20081, "_", V20082)
  ) %>%
  # Organizar a base pelos identificadores e trimestres
  arrange(id_individuo, Ano, Trimestre) %>%
  # Adicionar as outras colunas e variáveis necessárias
  mutate(
    faixa_idade_14_24 = ifelse(V2009 >= 14 & V2009 <= 24, 1, 0),
    ensino_medio_dummie = ifelse(V3003A == "Regular do ensino médio", 1, 0),
    residencia_unipessoal = ifelse(VD2004 == "Unipessoal", 1, 0),
    rede_publica = ifelse(V3002A == "Rede pública", 1, 0),
    
    # Calcular RDPC (Renda Domiciliar Per Capita)
    RD = sum(VD4020, na.rm = TRUE),          # Rendimento domiciliar total
    V2001R = ifelse(!is.na(V2001), V2001[1], NA),  # Número de residentes no domicílio
    RDPC = RD / V2001R,                      # Renda domiciliar per capita
    
    # Criar a dummy para renda per capita menor que 706
    renda_per_capta_menor_706 = ifelse(RDPC < 706, 1, 0),
    
    # Adicionar a coluna de região
    região = case_when(
      substr(UPA, start = 1, stop = 1) == '1' ~ 'Norte',
      substr(UPA, start = 1, stop = 1) == '2' ~ 'Nordeste',
      substr(UPA, start = 1, stop = 1) == '3' ~ 'Sudeste',
      substr(UPA, start = 1, stop = 1) == '4' ~ 'Sul',
      substr(UPA, start = 1, stop = 1) == '5' ~ 'Centro-Oeste',
      TRUE ~ NA_character_
    ),
    
    # Identificar a educação da mãe e do pai
    is_mae = (as.numeric(V2007) == 2 & (as.numeric(VD2002) %in% c(1, 2, 6))),
    educacao_mae = ifelse(any(is_mae), VD3005[is_mae][1], NA),
    is_pai = (as.numeric(V2007) == 1 & (as.numeric(VD2002) %in% c(1, 2, 6))),
    educacao_pai = ifelse(any(is_pai), VD3005[is_pai][1], NA),
    
    # Criar a dummie de abandono: matriculado no trimestre anterior e não matriculado no trimestre atual
    abandono = ifelse(
      lag(V3002) == "Sim" & V3002 == "Não" & lag(Ano) == Ano,
      1,
      0
    )
  ) %>%
  # Remover as colunas auxiliares usadas para identificar pais e mães
  select(-is_mae, -is_pai)


# Reorganizando as colunas para trazer as novas variáveis para o começo
base_abandono_filtrada <- base_abandono %>%
  dplyr::select( 
    id_individuo,Ano, Trimestre, faixa_idade_14_24, ensino_medio_dummie, residencia_unipessoal,
    rede_publica, renda_per_capta_menor_706, RDPC, região, educacao_mae, educacao_pai, abandono,
    everything()
  )

## Removendo observações onde V20082 é igual a 9999
base_abandono_filtrada<- base_evasão_filtrada %>%
  filter(V20082 != 9999)


######################################## Tamanho do problema####################################################

## Definindo os 3 públicos


# Público potencial (14-24 anos, RDPC < 706)
publico_pontencial <- base_abandono_filtrada %>%
  filter(
    V2009 >= 14 & V2009 <= 24 & RDPC < 706
  )

# Público EM público (Rede pública, 14-24 anos)
em_publico <- base_abandono_filtrada %>%
  filter(
    V3002A == "Rede pública" & V2009 >= 14 & V2009 <= 24
  )

# Público alvo PDM (Rede pública, Ensino médio regular, RDPC < 706)
beneficiários_pdm <- base_abandono_filtrada %>%
  filter(
    V2009 >= 14 & V2009 <= 24 &          # Faixa etária de 14 a 24 anos
      V3002A == "Rede pública" &           # Escola pública
      V3003A == "Regular do ensino médio" & # Ensino médio regular
      RDPC < 706                           # Renda per capita menor que 706 reais
  )

######################## Evasão por série ########################

# Calcular a evasão por série para o público potencial
evasao_publico_potencial <- publico_pontencial %>%
  group_by(V3006) %>%  # Agrupar por série
  summarise(
    evasao_total = sum(evasão, na.rm = TRUE),  # Soma das evasões
    total_alunos = n(),                        # Total de alunos
    taxa_evasao = evasao_total / total_alunos  # Taxa de evasão
  )

# Calcular a evasão por série para o público EM público
evasao_em_publico <- em_publico %>%
  group_by(V3006) %>%  # Agrupar por série
  summarise(
    evasao_total = sum(evasão, na.rm = TRUE),  # Soma das evasões
    total_alunos = n(),                        # Total de alunos
    taxa_evasao = evasao_total / total_alunos  # Taxa de evasão
  )

# Calcular a evasão por série para os beneficiários PDM
evasao_publico_alvo <- beneficiários_pdm %>%
  group_by(V3006) %>%  # Agrupar por série
  summarise(
    evasao_total = sum(evasão, na.rm = TRUE),  # Soma das evasões
    total_alunos = n(),                        # Total de alunos
    taxa_evasao = evasao_total / total_alunos  # Taxa de evasão
  )



############################################### Motivos da evasão###############################################

# Logit em painel, público potencial

modelo_logit_simples <- plm(
  evasão ~ região + educacao_mae + educacao_pai+ V2001 + V2007 + V2009 + V2010 + 
    VD2004 + VD3004 + RDPC + V3001,
  data = publico_pontencial,
  model = "pooling"  # Modelo de dados agrupados (sem efeitos fixos ou aleatórios)
)

# Logit em painel, efeito fixo, público pontecial

modelo_logit_potencial <- feglm(
  evasão ~ região + educacao_mae + educacao_pai + V1022 + V2001 + V2007 + V2009 + V2010 + 
    VD2004 + VD3004 + RDPC + V3001 | id_individuo,
  data = publico_pontencial,
  family = binomial(link = "logit")
)


# Logit em painel, EM público

modelo_logit_em_publico <- plm(
  evasão ~ região + educacao_mae + educacao_pai+ V2001 + V2007 + V2009 + V2010 + 
    VD2004 + VD3004 + RDPC + V3001,
  data = em_publico_painel,
  model = "pooling"  # Modelo pooling (sem efeitos fixos ou aleatórios)
)

# Logit em painel, efeito fixo, EM público

modelo_logit_em_publico <- feglm(
  evasão ~ região + educacao_mae + educacao_pai + V2001 + V2007 + V2009 + V2010 + 
    VD2004 + VD3004 + RDPC + V3001 | id_individuo,
  data = em_publico,
  family = binomial(link = "logit")
)


# Logit em painel, público alvo

modelo_logit_publico_alvo <- plm(
  evasão ~ região + educacao_mae + educacao_pai + V2001 + V2007 + V2009 + V2010 + 
    VD2004 + VD3004 + RDPC + V3001,
  data = beneficiarios_pdm_painel,
  model = "pooling"  # Modelo pooling (sem efeitos fixos ou aleatórios)
)


# Logit em painel, efeito fixo, público alvo.

modelo_logit_publico_alvo <- feglm(
  evasão ~ região + educacao_mae + educacao_pai + V2001 + V2007 + V2009 + V2010 + 
    VD2004 + VD3004 + RDPC + V3001 | id_individuo,
  data = beneficiários_pdm,
  family = binomial(link = "logit")
)



########## Variáveis de interesse ###########################################################################



1. #2010: Cor ou raça, #V2007: Sexo, #V2009: Idade do morador na data de referência

2. # região, #V1022: Situação do domicílio

3. # educacao_mae , educacao_pai , max educ pai/mãe, # RDPC : Rendimento domiciliar per capta

4 #V2001: Número de pessoas no domicílio,  #VD2004: Espécie da unidade doméstica












#VD3004: Nível de instrução mais elevado alcançado



# V3001: Sabe ler e escrever?


################################### Número evasão################################################################

# Verificar evasões em todas as transições de trimestre
evasoes_todos_periodos <- publico_alvo_filtrado %>%
  group_by(id_individuo) %>%
  summarise(
    # Verificar matrícula no 1º trimestre e ausência no 2º trimestre
    evasao_1_para_2 = any(Trimestre == "1" & V3003A == "Regular do ensino médio") & 
      !any(Trimestre == "2" & V3003A == "Regular do ensino médio"),
    
    # Verificar matrícula no 2º trimestre e ausência no 3º trimestre
    evasao_2_para_3 = any(Trimestre == "2" & V3003A == "Regular do ensino médio") & 
      !any(Trimestre == "3" & V3003A == "Regular do ensino médio"),
    
    # Verificar matrícula no 3º trimestre e ausência no 4º trimestre
    evasao_3_para_4 = any(Trimestre == "3" & V3003A == "Regular do ensino médio") & 
      !any(Trimestre == "4" & V3003A == "Regular do ensino médio")
  ) %>%
  # Filtrar indivíduos que tiveram evasão em qualquer um dos períodos
  filter(evasao_1_para_2 | evasao_2_para_3 | evasao_3_para_4) %>%
  ungroup()

# Verificar o número total de indivíduos que tiveram evasão em qualquer período
numero_total_de_evasoes <- nrow(evasoes_todos_periodos)
print(numero_total_de_evasoes)




